(in-package :setzkasten)

(defclass parser-state ()
  ((clef :initform '(:f . 7)
         :accessor clef
         :documentation "This slot carries the current clef state when reading the score encoding.")
   (accidental :initform nil
               :accessor accidental
               :documentation "This slot carries the current accidental state when reading the score encoding. This can only be :sharp, :flat or :natural, in the form of '(:sharp . 7). Enharmonic alterations are always processed within one glyph, therefore they don't need a state slot.")
   (f-clef-flag :initform nil
                :accessor f-clef-flag
                :documentation "This slot is T when a maxima glyph is used to express an f-clef.")
   (duration-override :initform nil
                      :accessor duration-override
                      :documentation "If nil, this will be ignored. Any integer or ratio will be used to modify the duration value when typesetting with lilypond. It can be used to create the effect of tuplets.")
   (key-signature :initform '(nil nil nil nil nil nil nil)
                  :accessor key-signature
                  :documentation "This carries information about key signatures. It is provided in the form of a list of 7 atoms, describing the alterations of a c major scale (see Lilypond key signature syntax), either with nil, :flat or :sharp.")
   (meter :initform nil
          :accessor meter
          :documentation "This contains a list with three symbols, the first being :circle or :semicircle, the second being :dot or nil and the third being :cut or nil.")
   (section-ids :initform nil
               :accessor section-ids
               :documentation "This symbol carries the current section id, it is used to direct score information into the correct `section' instance.")
   (voice-id :initform nil
             :accessor voice-id
             :documentation "This symbol carries the current voice id, it is used to direct score information into the correct `voice' instance.")
   (object-id-counter :initform 0
                      :accessor object-id-counter
                      :documentation "This counter can be used to create unique ids for score objects. The car represents the line, the cdr the musical object.")
   (divider-flag :initform nil
                 :accessor divider-flag
                 :documentation "Registers divider-information in the score encoding data, so that the mobject slot `divider' can be set for the next note accordingly.")
   (segno-flag :initform nil
               :accessor segno-flag
               :documentation "Registers a 'segno'-sign belonging to a note, will be transferred into the `mobject'.")
   (ligature-flag :initform nil
                  :accessor ligature-flag
                  :documentation "List representing the information inside a ligature definition, the first and second elements are the chromatic alteration at the beginning or the end of a ligature, the third and fourth elements are the enharmonic alteration.")
   (line-headings :initform nil
                  :accessor line-headings
                  :documentation "Stores a list of strings representing line headings (on the level of subtitles). It will be recursively shortened while parsing the score data.")
   (bracket-configuration :initform nil
                          :accessor bracket-configuration
                          :documentation "Stores dimensions relevant for the lilypond-rendering of bracketed staffs.")
   (voice-order :initform nil
                :accessor voice-order
                :documentation "If nil, voices and sections are ordered by creation time. If T, the score will be ordered after parsing according to this list."))
  (:documentation "This class keeps track of various elements during the reading process of score encoding data."))


(defmethod update-clef ((parser-state parser-state) root-pitch staff-position)
  "`root-pitch': :c :f or :g, `staff-position': 0-10."
  (cancel-f-clef-flag parser-state)
  (setf (clef parser-state) (cons root-pitch staff-position)))

(defmethod set-accidental ((parser-state parser-state) accidental staff-position)
  "`accidental': :sharp, :flat or :natural."
  (unless (ligature-flag parser-state)
    (setf (accidental parser-state) (cons accidental staff-position))))

(defmethod cancel-accidental ((parser-state parser-state))
  (setf (accidental parser-state) nil))

(defmethod raise-f-clef-flag ((parser-state parser-state))
  (setf (f-clef-flag parser-state) t))

(defmethod cancel-f-clef-flag ((parser-state parser-state))
  (setf (f-clef-flag parser-state) nil))

(defmethod set-duration-override ((parser-state parser-state) override)
  (setf (duration-override parser-state)
        (cond ((null override) nil)
              ((= override 1) nil)
              (t override))))

(defmethod set-ligature-flag ((parser-state parser-state) data)
  (setf (ligature-flag parser-state) data))

(defmethod deactivate-ligature-flag ((parser-state parser-state))
  (setf (ligature-flag parser-state) nil))

(defmethod set-key-signature ((parser-state parser-state) accidental-list)
  "`flat-list' and `sharp-list' both contain numbers representing the staff-positions, 0-10."
  (setf (key-signature parser-state) accidental-list))

(defmethod reset-divider-flag ((parser-state parser-state))
  (setf (divider-flag parser-state) nil))

(defmethod reset-segno-flag ((parser-state parser-state))
  (setf (segno-flag parser-state) nil))

(defmethod set-segno-flag ((parser-state parser-state))
  (setf (segno-flag parser-state) t))

(defmethod set-line-headings ((parser-state parser-state) heading-list)
  (setf (line-headings parser-state) heading-list))

(defmethod pop-line-heading ((parser-state parser-state))
  (let ((result (first (line-headings parser-state))))
    (setf (line-headings parser-state) (rest (line-headings parser-state)))
    result))

(defparameter *gamut*
  '((:c . 1) (:d . 1) (:e . 1) (:f . 1) (:g . 1) (:a . 1) (:b . 1)
    (:c . 2) (:d . 2) (:e . 2) (:f . 2) (:g . 2) (:a . 2) (:b . 2)
    (:c . 3) (:d . 3) (:e . 3) (:f . 3) (:g . 3) (:a . 3) (:b . 3)
    (:c . 4) (:d . 4) (:e . 4) (:f . 4) (:g . 4) (:a . 4) (:b . 4)
    (:c . 5))
  "This is used to calculate an absolute note name (lettera) based on staff position, clef letter and clef position.")

(defparameter *dict-clef-gamut*
  '((:c . (:c . 3))
    (:f . (:f . 2))
    (:g . (:g . 3)))
  "This represents the absolute position of each clef's reference note name within the *gamut*.")

(defun clef->root-pitch (clef)
  "Takes a `clef' in the form of '(:c . 7) and returns a root pitch of the clefs reference note in the form of '(:c . 3), which is pitchclass (lettera) and octave indicator."
  (cdr (assoc (first clef) *dict-clef-gamut*)))

(defun glyph->root-pitch (clef staff-position)
  "Returns a note name letter (lettera) as a keyword."
  (nth (- (position (clef->root-pitch clef) *gamut* :test #'equal)
          (- (cdr clef) staff-position))
       *gamut*))

(defmethod parse-pitch ((parser-state parser-state) staff-position)
  "Returns three values based on `parser-state' and `staff-position': the root note name (`lettera'), the chromatic alteration (:sharp, :flat or :natural) considering the current key signature and the octave (1-5)."
  (let ((root-pitch (glyph->root-pitch (clef parser-state) staff-position)))
    (values (car root-pitch)
            (let ((system-accidental (nth (position (car root-pitch) '(:c :d :e :f :g :a :b))
                                          (key-signature parser-state))))
              (if (eq (cdr (accidental parser-state)) staff-position)
                  (let ((local-accidental (car (accidental parser-state))))
                    (cancel-accidental parser-state)
                    (if (and (eq system-accidental :flat)
                             (eq local-accidental :natural))
                        nil
                        (or local-accidental system-accidental)))
                  system-accidental))
            (cdr root-pitch))))

(defun generate-object-id (counter)
  (intern (format nil "OB~a" counter)))

(defmethod add-note ((score score) (parser-state parser-state) duration dottedp staff-position enharmonic-dot)
  "Create an instance of `mobject' and add it to the `score'. `duration' as keywords (:brevis, :semibrevis, etc.), `dottedp' is T if there is a rhythmic dot ahead, `enharmonic-dot' can be nil, :dot or :comma."
  ;; (format t "~&adding ~a" staff-position)
  (let ((note-instance (multiple-value-bind (lettera chromatic-accidental octave)
                                    (parse-pitch parser-state staff-position)
                                  (make-note (generate-object-id (object-id-counter parser-state))
                                             lettera
                                             chromatic-accidental
                                             enharmonic-dot
                                             octave
                                             duration
                                             dottedp
                                             (duration-override parser-state)
                                             (clef parser-state)
                                             (key-signature parser-state)
                                             (ligature-flag parser-state)
                                             (divider-flag parser-state)
                                             (segno-flag parser-state)
                                             (meter parser-state)))))
    (mapc (lambda (section-id)
            (add-mobject-to-score score
                                  section-id
                                  (voice-id parser-state)
                                  note-instance))
          (section-ids parser-state)))

  (reset-divider-flag parser-state)
  (reset-segno-flag parser-state))


(defmethod add-rest ((score score) (parser-state parser-state) duration dottedp)
  (let ((rest-instance (make-rest (generate-object-id (object-id-counter parser-state))
                                           duration
                                           dottedp
                                           (duration-override parser-state)
                                           (clef parser-state)
                                           (key-signature parser-state)
                                           (divider-flag parser-state)
                                           (meter parser-state))))
    (mapc (lambda (section-id)
            (add-mobject-to-score score
                                  section-id
                                  (voice-id parser-state)
                                  rest-instance))
          (section-ids parser-state)))
  (reset-divider-flag parser-state))

;; (defmacro configure-parser (glyph-list)
;;   `(defmethod parse-glyph ((score score) (parser-state parser-state) glyph dottedp)
;;      (case glyph
;;        ,@(mapcar (lambda (definition)
;;                    (case (first definition)
;;                      (:note `(,(second definition) (add-note score
;;                                                              parser-state
;;                                                              ,(third definition)
;;                                                              dottedp
;;                                                              ,(fourth definition)
;;                                                              ,(fifth definition))))
;;                      (:rest `(,(second definition) (add-rest score
;;                                                              parser-state
;;                                                              ,(third definition)
;;                                                              dottedp)))
;;                      (:accidental `(,(second definition) (set-accidental parser-state
;;                                                                          ,(third definition)
;;                                                                          ,(fourth definition))))
;;                      (:clef `(,(second definition) (update-clef parser-state
;;                                                                 ,(third definition)
;;                                                                 ,(fourth definition))))))
;;           glyph-list))))



(defun read-parser-configuration (location)
  (with-open-file (config-file (merge-pathnames *configuration-path*
                                                (pathname location))
                               :direction :input)
    (eval (read config-file))))

;; does not work yet. should be moved to dispatcher code section, if possible
                                        ;(read-parser-configuration "parser-configuration.lisp")




(defun detect-dots (rest-music dot-list note-list)
  (dolist (item rest-music)
    (when (member item dot-list) (return t))
    (when (member item note-list) (return nil))))

(defmethod dump-bracket-info ((score score) (parser-state parser-state))
  (mapc (lambda (section-id)
          (set-section-bracket* score section-id
                                (cdr (assoc section-id (bracket-configuration parser-state)))))
        (section-ids parser-state)))

(defmethod process-music ((score score) (parser-state parser-state) music-data)
  "Process a :music field in the score encoding data, element by element. Populate the `score' instance."
  (dolist (music-line music-data (sort-score score (voice-order parser-state)))
    (when (eq :music (first music-line))
      (do ((rest-music (rest (rest music-line)) (rest rest-music)))
          ((null rest-music) nil)
        (let ((candidate (first rest-music)))
          (if (listp candidate)
              (case (first candidate)
                (:section
                 (unless (section-ids parser-state)
                   (set-line-heading score (second candidate) (pop-line-heading parser-state)))
                 (setf (section-ids parser-state) (rest candidate)))
                (:voice (setf (voice-id parser-state) (second candidate)))
                (:f-clef (raise-f-clef-flag parser-state))
                (:bracketed (dump-bracket-info score parser-state))
                (:duration-override (set-duration-override parser-state (second candidate)))
                (:meter-override (setf (meter parser-state) candidate))
                (:ligature-start (set-ligature-flag parser-state (rest candidate)))
                (:ligature-end (deactivate-ligature-flag parser-state))
                (:newline
                 (mapc (lambda (section-id) (set-newline score section-id))
                       (section-ids parser-state))
                 (mapc (lambda (section-id) (set-line-heading score section-id
                                                              (pop-line-heading parser-state)))
                       (section-ids parser-state)))
                (:divider (setf (divider-flag parser-state) (second candidate)))
                (:segno (set-segno-flag parser-state))
                (:key-signature
                 (set-key-signature parser-state (rest candidate))
                 (cancel-accidental parser-state))))
          ;; here the glyph processing happens
          (when (member candidate *f-clef-triggers*)
            (cancel-f-clef-flag parser-state))
          (if (member candidate *meter-signatures* :key #'first)
              (setf (meter parser-state) (cdr (assoc candidate *meter-signatures*)))
              (unless (f-clef-flag parser-state)
                (parse-glyph score
                             parser-state
                             candidate
                             (detect-dots (rest rest-music)
                                          *list-of-duration-dots*
                                          *list-of-notes*)))
     ))))))

;; attention when adding new keywords: the order matters. score source code expects header items
;; to be parsed first, then lilypond items. This is important for the consistency of the order of
;; voices in a score.

(defmethod process-metadata ((score score) (parser-state parser-state) score-data)
  "Process the backend-agnostic :header information in the score encoding data and
   write it into the `score' instance."
  (setf (filename score) (first (extract-item :header :filename score-data)))
  (setf (title score) (first (extract-item :header :title score-data)))
  (setf (comment score) (first (extract-item :header :comment score-data)))
  (setf (creator score) (first (extract-item :header :creator score-data)))
  (let ((headings (extract-item :header :section-headings score-data)))
    (when headings
      (mapc (lambda (this-heading)
              (when this-heading
                (set-section-heading* score (first this-heading) (second this-heading))))
            headings)))
  (let ((captions (extract-item :header :section-captions score-data)))
    (when captions
      (mapc (lambda (this-caption)
              (when this-caption
                (set-section-caption* score (first this-caption) (second this-caption))))
            captions)))
  (let ((headings (extract-item :header :line-headings score-data)))
    (when headings
      (set-line-headings parser-state headings)))
  (let ((voice-order (extract-item :header :voice-order score-data)))
    (when voice-order
      (setf (voice-order parser-state) voice-order)))
  (let ((label-list (extract-item :header :voice-labels score-data)))
    (when label-list
      (mapc (lambda (this-label)
              (when this-label
                (if (eq (first this-label) :all)
                    (dolist (this-section (sections score))
                      (set-voice-label* score
                                        (id this-section)
                                        (second this-label)
                                        (third this-label)))
                    (set-voice-label* score
                                      (first this-label)
                                      (second this-label)
                                      (third this-label)))))
            label-list)))
  (let ((clef-overrides (extract-item :preamble-lilypond :clef-overrides score-data)))
    (when clef-overrides
      (dolist (override clef-overrides)
        (set-clef-override* score (first override) (second override) (third override)))))
  (let ((bracket-configuration (extract-item :preamble-lilypond :brackets score-data)))
    (when bracket-configuration
      (setf (bracket-configuration parser-state) bracket-configuration)))
  (let ((standalone-title (extract-item :preamble-lilypond :standalone-title score-data)))
    (when standalone-title
      (setf (standalone-title score) (car standalone-title))))
  (let ((standalone-subtitle (extract-item :preamble-lilypond :standalone-subtitle score-data)))
    (when standalone-subtitle
      (setf (standalone-subtitle score) (car standalone-subtitle))))
  (let ((lyrics (extract-item :preamble-lilypond :lyrics score-data)))
    (when lyrics
      (dolist (voice-lyrics lyrics)
        (set-voice-lyrics* score (first voice-lyrics) (second voice-lyrics) (third voice-lyrics))))))

(defun parse-score (data &optional (suffix "x"))
  (let ((score (make-instance 'score))
        (parser-state-instance (make-instance 'parser-state)))
    (process-metadata score parser-state-instance data)
    (process-music score parser-state-instance (extract-category :data data))
    (with-open-file (logfile (merge-pathnames *log-file-path*
                                              (pathname (format nil "~a-~a.txt"
                                                                (filename score)
                                                                suffix)))
                             :direction :output
                             :if-exists :supersede
                             :if-does-not-exist :create)
      (print-element score logfile))
    score))



;; TODO this list is too long and causes a stack overflow. Solutions:
;; Either delete items that are not needed, or enlarge the stack size.

;; Attempt for a solution: replace the macro with a hand coded huge case statement.


(defmethod parse-glyph ((score score) (parser-state parser-state) glyph dottedp)
  ;; (format t "~&parsing ~a" glyph)
  (let ((keyword-glyph (if (atom glyph)
                           (make-keyword glyph)
                           nil)))
    (case keyword-glyph
      (:sh0 (set-accidental parser-state :sharp 0))
      (:sh1 (set-accidental parser-state :sharp 1))
      (:sh2 (set-accidental parser-state :sharp 2))
      (:sh3 (set-accidental parser-state :sharp 3))
      (:sh4 (set-accidental parser-state :sharp 4))
      (:sh5 (set-accidental parser-state :sharp 5))
      (:sh6 (set-accidental parser-state :sharp 6))
      (:sh7 (set-accidental parser-state :sharp 7))
      (:sh8 (set-accidental parser-state :sharp 8))
      (:sh9 (set-accidental parser-state :sharp 9))
      (:sh10 (set-accidental parser-state :sharp 10))
      (:fl0 (set-accidental parser-state :flat 0))
      (:fl1 (set-accidental parser-state :flat 1))
      (:fl2 (set-accidental parser-state :flat 2))
      (:fl3 (set-accidental parser-state :flat 3))
      (:fl4 (set-accidental parser-state :flat 4))
      (:fl5 (set-accidental parser-state :flat 5))
      (:fl6 (set-accidental parser-state :flat 6))
      (:fl7 (set-accidental parser-state :flat 7))
      (:fl8 (set-accidental parser-state :flat 8))
      (:fl9 (set-accidental parser-state :flat 9))
      (:fl10 (set-accidental parser-state :flat 10))
      (:fl11 (set-accidental parser-state :flat 11))
      (:nat0 (set-accidental parser-state :natural 0))
      (:nat1 (set-accidental parser-state :natural 1))
      (:nat2 (set-accidental parser-state :natural 2))
      (:nat3 (set-accidental parser-state :natural 3))
      (:nat4 (set-accidental parser-state :natural 4))
      (:nat5 (set-accidental parser-state :natural 5))
      (:nat6 (set-accidental parser-state :natural 6))
      (:nat7 (set-accidental parser-state :natural 7))
      (:nat8 (set-accidental parser-state :natural 8))
      (:nat9 (set-accidental parser-state :natural 9))
      (:nat10 (set-accidental parser-state :natural 10))
      (:flrev4 (set-accidental parser-state :flat 4))


      (:cclef1 (update-clef parser-state :c 1))
      (:cclef3 (update-clef parser-state :c 3))
      (:cclef5 (update-clef parser-state :c 5))
      (:cclef7 (update-clef parser-state :c 7))
      (:cclef9 (update-clef parser-state :c 9))
      (:fclef1 (update-clef parser-state :f 1))
      (:fclef3 (update-clef parser-state :f 3))
      (:fclef5 (update-clef parser-state :f 5))
      (:fclef7 (update-clef parser-state :f 7))
      (:fclef9 (update-clef parser-state :f 9))
      (:gclef3 (update-clef parser-state :g 3))
      (:max6 (add-note score parser-state :maxima dottedp 6 nil))
      (:max7 (add-note score parser-state :maxima dottedp 7 nil))
      (:longa1 (add-note score parser-state :longa dottedp 1 nil))
      (:longa3 (add-note score parser-state :longa dottedp 1 nil))
      (:longa4 (add-note score parser-state :longa dottedp 4 nil))
      (:longa5 (add-note score parser-state :longa dottedp 5 nil))
      (:longa7 (add-note score parser-state :longa dottedp 7 nil))
      (:longa8 (add-note score parser-state :longa dottedp 8 nil))
      (:longa9 (add-note score parser-state :longa dottedp 9 nil))

      (:br-1 (add-note score parser-state :brevis dottedp -1 nil))
      (:br0 (add-note score parser-state :brevis dottedp 0 nil))
      (:br1 (add-note score parser-state :brevis dottedp 1 nil))
      (:br2 (add-note score parser-state :brevis dottedp 2 nil))
      (:br3 (add-note score parser-state :brevis dottedp 3 nil))
      (:br4 (add-note score parser-state :brevis dottedp 4 nil))
      (:br5 (add-note score parser-state :brevis dottedp 5 nil))
      (:br6 (add-note score parser-state :brevis dottedp 6 nil))
      (:br7 (add-note score parser-state :brevis dottedp 7 nil))
      (:br8 (add-note score parser-state :brevis dottedp 8 nil))
      (:br9 (add-note score parser-state :brevis dottedp 9 nil))
      (:br10 (add-note score parser-state :brevis dottedp 10 nil))

      (:brbl0 (add-note score parser-state :brevis dottedp 0 nil))
      (:brbl1 (add-note score parser-state :brevis dottedp 1 nil))
      (:brbl2 (add-note score parser-state :brevis dottedp 2 nil))
      (:brbl3 (add-note score parser-state :brevis dottedp 3 nil))
      (:brbl4 (add-note score parser-state :brevis dottedp 4 nil))
      (:brbl5 (add-note score parser-state :brevis dottedp 5 nil))
      (:brbl6 (add-note score parser-state :brevis dottedp 6 nil))
      (:brbl7 (add-note score parser-state :brevis dottedp 7 nil))
      (:brbl8 (add-note score parser-state :brevis dottedp 8 nil))
      (:brbl9 (add-note score parser-state :brevis dottedp 9 nil))
      (:brbl10 (add-note score parser-state :brevis dottedp 10 nil))

      (:brd0 (add-note score parser-state :brevis dottedp 0 :dot))
      (:brd1 (add-note score parser-state :brevis dottedp 1 :dot))
      (:brd2 (add-note score parser-state :brevis dottedp 2 :dot))
      (:brd3 (add-note score parser-state :brevis dottedp 3 :dot))
      (:brd4 (add-note score parser-state :brevis dottedp 4 :dot))
      (:brd5 (add-note score parser-state :brevis dottedp 5 :dot))
      (:brd6 (add-note score parser-state :brevis dottedp 6 :dot))
      (:brd7 (add-note score parser-state :brevis dottedp 7 :dot))
      (:brd8 (add-note score parser-state :brevis dottedp 8 :dot))
      (:brd9 (add-note score parser-state :brevis dottedp 9 :dot))
      (:brd10 (add-note score parser-state :brevis dottedp 10 :dot))

      ;; (:note brdl0 :brevis 0 :dot)
      ;; (:note brdl1 :brevis 1 :dot)
      ;; (:note brdl2 :brevis 2 :dot)
      ;; (:note brdl3 :brevis 3 :dot)
      ;; (:note brdl4 :brevis 4 :dot)
      (:brdl5 (add-note score parser-state :brevis dottedp 5 :dot))
      ;; (:note brdl6 :brevis 6 :dot)
      ;; (:note brdl7 :brevis 7 :dot)
      ;; (:note brdl8 :brevis 8 :dot)
      ;; (:note brdl9 :brevis 9 :dot)
      ;; (:note brdl10 :brevis 10 :dot)
      ;; (:note brdr0 :brevis 0 :dot)
      ;; (:note brdr1 :brevis 1 :dot)
      ;; (:note brdr2 :brevis 2 :dot)
      ;; (:note brdr3 :brevis 3 :dot)
      ;; (:note brdr4 :brevis 4 :dot)
      (:brdr5 (add-note score parser-state :brevis dottedp 5 :dot))
      ;; (:note brdr6 :brevis 6 :dot)
      ;; (:note brdr7 :brevis 7 :dot)
      ;; (:note brdr8 :brevis 8 :dot)
      ;; (:note brdr9 :brevis 9 :dot)
      ;; (:note brdr10 :brevis 10 :dot)

      (:brc7 (add-note score parser-state :brevis dottedp 7 :comma))
      (:brc8 (add-note score parser-state :brevis dottedp 8 :comma))

      (:sb0 (add-note score parser-state :semibrevis dottedp 0 nil))
      (:sb1 (add-note score parser-state :semibrevis dottedp 1 nil))
      (:sb2 (add-note score parser-state :semibrevis dottedp 2 nil))
      (:sb3 (add-note score parser-state :semibrevis dottedp 3 nil))
      (:sb4 (add-note score parser-state :semibrevis dottedp 4 nil))
      (:sb5 (add-note score parser-state :semibrevis dottedp 5 nil))
      (:sb6 (add-note score parser-state :semibrevis dottedp 6 nil))
      (:sb7 (add-note score parser-state :semibrevis dottedp 7 nil))
      (:sb8 (add-note score parser-state :semibrevis dottedp 8 nil))
      (:sb9 (add-note score parser-state :semibrevis dottedp 9 nil))
      (:sb10 (add-note score parser-state :semibrevis dottedp 10 nil))
      (:sb11 (add-note score parser-state :semibrevis dottedp 11 nil))

      (:sbbl0 (add-note score parser-state :semibrevis dottedp 0 nil))
      (:sbbl1 (add-note score parser-state :semibrevis dottedp 1 nil))
      (:sbbl2 (add-note score parser-state :semibrevis dottedp 2 nil))
      (:sbbl3 (add-note score parser-state :semibrevis dottedp 3 nil))
      (:sbbl4 (add-note score parser-state :semibrevis dottedp 4 nil))
      (:sbbl5 (add-note score parser-state :semibrevis dottedp 5 nil))
      (:sbbl6 (add-note score parser-state :semibrevis dottedp 6 nil))
      (:sbbl7 (add-note score parser-state :semibrevis dottedp 7 nil))
      (:sbbl8 (add-note score parser-state :semibrevis dottedp 8 nil))
      (:sbbl9 (add-note score parser-state :semibrevis dottedp 9 nil))
      (:sbbl10 (add-note score parser-state :semibrevis dottedp 10 nil))

      (:sbd0 (add-note score parser-state :semibrevis dottedp 0 :dot))
      (:sbd1 (add-note score parser-state :semibrevis dottedp 1 :dot))
      (:sbd2 (add-note score parser-state :semibrevis dottedp 2 :dot))
      (:sbd3 (add-note score parser-state :semibrevis dottedp 3 :dot))
      (:sbd4 (add-note score parser-state :semibrevis dottedp 4 :dot))
      (:sbd5 (add-note score parser-state :semibrevis dottedp 5 :dot))
      (:sbd6 (add-note score parser-state :semibrevis dottedp 6 :dot))
      (:sbd7 (add-note score parser-state :semibrevis dottedp 7 :dot))
      (:sbd8 (add-note score parser-state :semibrevis dottedp 8 :dot))
      (:sbd9 (add-note score parser-state :semibrevis dottedp 9 :dot))
      (:sbd10 (add-note score parser-state :semibrevis dottedp 10 :dot))

      (:sbdc5 (add-note score parser-state :semibrevis dottedp 5 :dot-comma))
      (:sbdc6 (add-note score parser-state :semibrevis dottedp 6 :dot-comma))

      ;; (:note sbdr0 :semibrevis 0 :dot)
      ;; (:note sbdr1 :semibrevis 1 :dot)
      ;; (:note sbdr2 :semibrevis 2 :dot)
      ;; (:note sbdr3 :semibrevis 3 :dot)
      (:sbdr4 (add-note score parser-state :semibrevis dottedp 4 :dot))
      ;; (:note sbdr5 :semibrevis 5 :dot)
      ;; (:note sbdr6 :semibrevis 6 :dot)
      ;; (:note sbdr7 :semibrevis 7 :dot)
      ;; (:note sbdr8 :semibrevis 8 :dot)
      ;; (:note sbdr9 :semibrevis 9 :dot)
      ;; (:note sbdl0 :semibrevis 0 :dot)
      ;; (:note sbdl1 :semibrevis 1 :dot)
      ;; (:note sbdl2 :semibrevis 2 :dot)
      ;; (:note sbdl3 :semibrevis 3 :dot)
      ;; (:note sbdl4 :semibrevis 4 :dot)
      ;; (:note sbdl5 :semibrevis 5 :dot)
      ;; (:note sbdl6 :semibrevis 6 :dot)
      (:sbdl7 (add-note score parser-state :semibrevis dottedp 7 :dot))
      ;; (:note sbdl8 :semibrevis 8 :dot)
      ;; (:note sbdl9 :semibrevis 9 :dot)
      ;; (:note sbc0 :semibrevis 0 :comma)
      (:sbc1 (add-note score parser-state :semibrevis dottedp 1 :comma))
      (:sbc2 (add-note score parser-state :semibrevis dottedp 2 :comma))
      (:sbc3 (add-note score parser-state :semibrevis dottedp 3 :comma))
      (:sbc4 (add-note score parser-state :semibrevis dottedp 4 :comma))
      (:sbc5 (add-note score parser-state :semibrevis dottedp 5 :comma))
      (:sbc6 (add-note score parser-state :semibrevis dottedp 6 :comma))
      (:sbc7 (add-note score parser-state :semibrevis dottedp 7 :comma))
      (:sbc8 (add-note score parser-state :semibrevis dottedp 8 :comma))
      (:sbc9 (add-note score parser-state :semibrevis dottedp 9 :comma))
      (:sbc10 (add-note score parser-state :semibrevis dottedp 10 :comma))
      (:m-1 (add-note score parser-state :minima dottedp -1 nil))
      (:m0 (add-note score parser-state :minima dottedp 0 nil))
      (:m1 (add-note score parser-state :minima dottedp 1 nil))
      (:m2 (add-note score parser-state :minima dottedp 2 nil))
      (:m3 (add-note score parser-state :minima dottedp 3 nil))
      (:m4 (add-note score parser-state :minima dottedp 4 nil))
      (:m5 (add-note score parser-state :minima dottedp 5 nil))
      (:m5d (add-note score parser-state :minima dottedp 5 nil))
      (:m6 (add-note score parser-state :minima dottedp 6 nil))
      (:m7 (add-note score parser-state :minima dottedp 7 nil))
      (:m8 (add-note score parser-state :minima dottedp 8 nil))
      (:m9 (add-note score parser-state :minima dottedp 9 nil))
      (:m10 (add-note score parser-state :minima dottedp 10 nil))
      (:md0 (add-note score parser-state :minima dottedp 0 :dot))
      (:md1 (add-note score parser-state :minima dottedp 1 :dot))
      (:md2 (add-note score parser-state :minima dottedp 2 :dot))
      (:md3 (add-note score parser-state :minima dottedp 3 :dot))
      (:md4 (add-note score parser-state :minima dottedp 4 :dot))
      (:md5 (add-note score parser-state :minima dottedp 5 :dot))
      (:md5d (add-note score parser-state :minima dottedp 5 :dot))
      (:md6 (add-note score parser-state :minima dottedp 6 :dot))
      (:md7 (add-note score parser-state :minima dottedp 7 :dot))
      (:md8 (add-note score parser-state :minima dottedp 8 :dot))
      (:md9 (add-note score parser-state :minima dottedp 9 :dot))
      (:md10 (add-note score parser-state :minima dottedp 10 :dot))

      ;; (:note mdr0 :minima 0 :dot)
      ;; (:note mdr1 :minima 1 :dot)
      ;; (:note mdr2 :minima 2 :dot)
      ;; (:note mdr3 :minima 3 :dot)
      ;; (:note mdr4 :minima 4 :dot)
      ;; (:note mdr5 :minima 5 :dot)
      ;; (:note mdr6 :minima 6 :dot)
      ;; (:note mdr7 :minima 7 :dot)
      ;; (:note mdr8 :minima 8 :dot)
      ;; (:note mdr9 :minima 9 :dot)
      ;; (:note mdr10 :minima 10 :dot)
      ;; (:note mdl0 :minima 0 :dot)
      ;; (:note mdl1 :minima 1 :dot)
      ;; (:note mdl2 :minima 2 :dot)
      ;; (:note mdl3 :minima 3 :dot)
      (:mdl4 (add-note score parser-state :minima dottedp 4 :dot))
      ;; (:note mdl5 :minima 5 :dot)
      ;; (:note mdl6 :minima 6 :dot)
      ;; (:note mdl7 :minima 7 :dot)
      ;; (:note mdl8 :minima 8 :dot)
      ;; (:note mdl9 :minima 9 :dot)
      ;; (:note mdl10 :minima 10 :dot)
      (:sm0 (add-note score parser-state :semiminima dottedp 0 nil))
      (:sm1 (add-note score parser-state :semiminima dottedp 1 nil))
      (:sm2 (add-note score parser-state :semiminima dottedp 2 nil))
      (:sm3 (add-note score parser-state :semiminima dottedp 3 nil))
      (:sm4 (add-note score parser-state :semiminima dottedp 4 nil))
      (:sm5 (add-note score parser-state :semiminima dottedp 5 nil))
      (:sm5d (add-note score parser-state :semiminima dottedp 5 nil))
      (:sm6 (add-note score parser-state :semiminima dottedp 6 nil))
      (:sm7 (add-note score parser-state :semiminima dottedp 7 nil))
      (:sm8 (add-note score parser-state :semiminima dottedp 8 nil))
      (:sm9 (add-note score parser-state :semiminima dottedp 9 nil))
      (:sm10 (add-note score parser-state :semiminima dottedp 10 nil))
      (:smd0 (add-note score parser-state :semiminima dottedp 0 :dot))
      (:smd1 (add-note score parser-state :semiminima dottedp 1 :dot))
      (:smd2 (add-note score parser-state :semiminima dottedp 2 :dot))
      (:smd3 (add-note score parser-state :semiminima dottedp 3 :dot))
      (:smd4 (add-note score parser-state :semiminima dottedp 4 :dot))
      (:smd5 (add-note score parser-state :semiminima dottedp 5 :dot))
      (:smd5d (add-note score parser-state :semiminima dottedp 5 :dot))
      (:smd6 (add-note score parser-state :semiminima dottedp 6 :dot))
      (:smd7 (add-note score parser-state :semiminima dottedp 7 :dot))
      (:smd8 (add-note score parser-state :semiminima dottedp 8 :dot))
      (:smd9 (add-note score parser-state :semiminima dottedp 9 :dot))
      (:smd10 (add-note score parser-state :semiminima dottedp 10 :dot))

      ;; (:note smdr1 :semiminima 1 :dot)
      ;; (:note smdr2 :semiminima 2 :dot)
      (:smdr3 (add-note score parser-state :semiminima dottedp 3 :dot))
      ;; (:note smdr4 :semiminima 4 :dot)
      ;; (:note smdr5 :semiminima 5 :dot)
      ;; (:note smdr6 :semiminima 6 :dot)
      ;; (:note smdr7 :semiminima 7 :dot)
      ;; (:note smdr8 :semiminima 8 :dot)
      ;; (:note smdr9 :semiminima 9 :dot)
      ;; (:note smdl1 :semiminima 1 :dot)
      ;; (:note smdl2 :semiminima 2 :dot)
      ;; (:note smdl3 :semiminima 3 :dot)
      ;; (:note smdl4 :semiminima 4 :dot)
      ;; (:note smdl5 :semiminima 5 :dot)
      ;; (:note smdl6 :semiminima 6 :dot)
      ;; (:note smdl7 :semiminima 7 :dot)
      ;; (:note smdl8 :semiminima 8 :dot)
      ;; (:note smdl9 :semiminima 9 :dot)
      (:cr0 (add-note score parser-state :croma dottedp 0 nil))
      (:cr1 (add-note score parser-state :croma dottedp 1 nil))
      (:cr2 (add-note score parser-state :croma dottedp 2 nil))
      (:cr3 (add-note score parser-state :croma dottedp 3 nil))
      (:cr4 (add-note score parser-state :croma dottedp 4 nil))
      (:cr5 (add-note score parser-state :croma dottedp 5 nil))
      (:cr5d (add-note score parser-state :croma dottedp 5 nil))
      (:cr6 (add-note score parser-state :croma dottedp 6 nil))
      (:cr7 (add-note score parser-state :croma dottedp 7 nil))
      (:cr8 (add-note score parser-state :croma dottedp 8 nil))
      (:cr9 (add-note score parser-state :croma dottedp 9 nil))
      (:cr10 (add-note score parser-state :croma dottedp 10 nil))
      (:crd7 (add-note score parser-state :croma dottedp 7 :dot))
      (:scr3 (add-note score parser-state :semicroma dottedp 3 nil))
      (:scr4 (add-note score parser-state :semicroma dottedp 4 nil))
      (:scr6 (add-note score parser-state :semicroma dottedp 6 nil))
      (:scr7 (add-note score parser-state :semicroma dottedp 7 nil))
      (:scrd2 (add-note score parser-state :semicroma dottedp 2 :dot))

      (:maxrest246 (add-rest score parser-state :maxima dottedp))
      (:lrest24 (add-rest score parser-state :longa dottedp))
      (:lrest46 (add-rest score parser-state :longa dottedp))
      (:lrest68 (add-rest score parser-state :longa dottedp))
      (:brrest2 (add-rest score parser-state :brevis dottedp))
      (:brrest4 (add-rest score parser-state :brevis dottedp))
      (:brrest6 (add-rest score parser-state :brevis dottedp))
      (:sbrest3 (add-rest score parser-state :semibrevis dottedp))
      (:sbrest5 (add-rest score parser-state :semibrevis dottedp))
      (:sbrest7 (add-rest score parser-state :semibrevis dottedp))
      (:sbrest9 (add-rest score parser-state :semibrevis dottedp))
      (:mrest1 (add-rest score parser-state :minima dottedp))
      (:mrest3 (add-rest score parser-state :minima dottedp))
      (:mrest5 (add-rest score parser-state :minima dottedp))
      (:mrest7 (add-rest score parser-state :minima dottedp))
      (:smrest1 (add-rest score parser-state :semiminima dottedp))
      (:smrest3 (add-rest score parser-state :semiminima dottedp))
      (:smrest5 (add-rest score parser-state :semiminima dottedp))
      (:smrest7 (add-rest score parser-state :semiminima dottedp))
      )))

;; (configure-parser
;;  ((:accidental sh0 :sharp 0)
;;   (:accidental sh1 :sharp 1)
;;   (:accidental sh2 :sharp 2)
;;   (:accidental sh3 :sharp 3)
;;   (:accidental sh4 :sharp 4)
;;   (:accidental sh5 :sharp 5)
;;   (:accidental sh6 :sharp 6)
;;   (:accidental sh7 :sharp 7)
;;   (:accidental sh8 :sharp 8)
;;   (:accidental sh9 :sharp 9)
;;   (:accidental sh10 :sharp 10)
;;   (:accidental fl0 :flat 0)
;;   (:accidental fl1 :flat 1)
;;   (:accidental fl2 :flat 2)
;;   (:accidental fl3 :flat 3)
;;   (:accidental fl4 :flat 4)
;;   (:accidental fl5 :flat 5)
;;   (:accidental fl6 :flat 6)
;;   (:accidental fl7 :flat 7)
;;   (:accidental fl8 :flat 8)
;;   (:accidental fl9 :flat 9)
;;   (:accidental fl10 :flat 10)
;;   (:accidental nat0 :natural 0)
;;   (:accidental nat1 :natural 1)
;;   (:accidental nat2 :natural 2)
;;   (:accidental nat3 :natural 3)
;;   (:accidental nat4 :natural 4)
;;   (:accidental nat5 :natural 5)
;;   (:accidental nat6 :natural 6)
;;   (:accidental nat7 :natural 7)
;;   (:accidental nat8 :natural 8)
;;   (:accidental nat9 :natural 9)
;;   (:accidental nat10 :natural 10)
;;   (:accidental flrev4 :flat 4)
;;   (:clef cclef1 :c 1)
;;   (:clef cclef3 :c 3)
;;   (:clef cclef5 :c 5)
;;   (:clef cclef7 :c 7)
;;   (:clef cclef9 :c 9)
;;   (:clef fclef1 :f 1)
;;   (:clef fclef3 :f 3)
;;   (:clef fclef5 :f 5)
;;   (:clef fclef7 :f 7)
;;   (:clef fclef9 :f 9)
;;   (:clef gclef3 :g 3)
;;   (:note max6 :maxima 6)
;;   (:note max7 :maxima 7)
;;   (:note longa1 :longa 1)
;;   (:note longa3 :longa 1)
;;   (:note longa4 :longa 4)
;;   (:note longa5 :longa 5)
;;   (:note longa7 :longa 7)
;;   (:note longa8 :longa 8)
;;   (:note longa9 :longa 9)

;;   (:note br-1 :brevis -1)
;;   (:note br0 :brevis 0)
;;   (:note br1 :brevis 1)
;;   (:note br2 :brevis 2)
;;   (:note br3 :brevis 3)
;;   (:note br4 :brevis 4)
;;   (:note br5 :brevis 5)
;;   (:note br6 :brevis 6)
;;   (:note br7 :brevis 7)
;;   (:note br8 :brevis 8)
;;   (:note br9 :brevis 9)
;;   (:note br10 :brevis 10)

;;   (:note brbl0 :brevis 0)
;;   (:note brbl1 :brevis 1)
;;   (:note brbl2 :brevis 2)
;;   (:note brbl3 :brevis 3)
;;   (:note brbl4 :brevis 4)
;;   (:note brbl5 :brevis 5)
;;   (:note brbl6 :brevis 6)
;;   (:note brbl7 :brevis 7)
;;   (:note brbl8 :brevis 8)
;;   (:note brbl9 :brevis 9)
;;   (:note brbl10 :brevis 10)

;;   (:note brd0 :brevis 0 :dot)
;;   (:note brd1 :brevis 1 :dot)
;;   (:note brd2 :brevis 2 :dot)
;;   (:note brd3 :brevis 3 :dot)
;;   (:note brd4 :brevis 4 :dot)
;;   (:note brd5 :brevis 5 :dot)
;;   (:note brd6 :brevis 6 :dot)
;;   (:note brd7 :brevis 7 :dot)
;;   (:note brd8 :brevis 8 :dot)
;;   (:note brd9 :brevis 9 :dot)
;;   (:note brd10 :brevis 10 :dot)

;;   (:note brdl0 :brevis 0 :dot)
;;   (:note brdl1 :brevis 1 :dot)
;;   (:note brdl2 :brevis 2 :dot)
;;   (:note brdl3 :brevis 3 :dot)
;;   (:note brdl4 :brevis 4 :dot)
;;   (:note brdl5 :brevis 5 :dot)
;;   (:note brdl6 :brevis 6 :dot)
;;   (:note brdl7 :brevis 7 :dot)
;;   (:note brdl8 :brevis 8 :dot)
;;   (:note brdl9 :brevis 9 :dot)
;;   (:note brdl10 :brevis 10 :dot)
;;   (:note brdr0 :brevis 0 :dot)
;;   (:note brdr1 :brevis 1 :dot)
;;   (:note brdr2 :brevis 2 :dot)
;;   (:note brdr3 :brevis 3 :dot)
;;   (:note brdr4 :brevis 4 :dot)
;;   (:note brdr5 :brevis 5 :dot)
;;   (:note brdr6 :brevis 6 :dot)
;;   (:note brdr7 :brevis 7 :dot)
;;   (:note brdr8 :brevis 8 :dot)
;;   (:note brdr9 :brevis 9 :dot)
;;   (:note brdr10 :brevis 10 :dot)

;;   (:note brc7 :brevis 7 :comma)
;;   (:note brc8 :brevis 8 :comma)

;;   (:note sb0 :semibrevis 0)
;;   (:note sb1 :semibrevis 1)
;;   (:note sb2 :semibrevis 2)
;;   (:note sb3 :semibrevis 3)
;;   (:note sb4 :semibrevis 4)
;;   (:note sb5 :semibrevis 5)
;;   (:note sb6 :semibrevis 6)
;;   (:note sb7 :semibrevis 7)
;;   (:note sb8 :semibrevis 8)
;;   (:note sb9 :semibrevis 9)
;;   (:note sb10 :semibrevis 10)
;;   (:note sb11 :semibrevis 11)

;;   (:note sbbl0 :semibrevis 0)
;;   (:note sbbl1 :semibrevis 1)
;;   (:note sbbl2 :semibrevis 2)
;;   (:note sbbl3 :semibrevis 3)
;;   (:note sbbl4 :semibrevis 4)
;;   (:note sbbl5 :semibrevis 5)
;;   (:note sbbl6 :semibrevis 6)
;;   (:note sbbl7 :semibrevis 7)
;;   (:note sbbl8 :semibrevis 8)
;;   (:note sbbl9 :semibrevis 9)
;;   (:note sbbl10 :semibrevis 10)

;;   (:note sbd0 :semibrevis 0 :dot)
;;   (:note sbd1 :semibrevis 1 :dot)
;;   (:note sbd2 :semibrevis 2 :dot)
;;   (:note sbd3 :semibrevis 3 :dot)
;;   (:note sbd4 :semibrevis 4 :dot)
;;   (:note sbd5 :semibrevis 5 :dot)
;;   (:note sbd6 :semibrevis 6 :dot)
;;   (:note sbd7 :semibrevis 7 :dot)
;;   (:note sbd8 :semibrevis 8 :dot)
;;   (:note sbd9 :semibrevis 9 :dot)
;;   (:note sbd10 :semibrevis 10 :dot)

;;   (:note sbdc5 :semibrevis 5 :dot-comma)
;;   (:note sbdc6 :semibrevis 6 :dot-comma)

;;   (:note sbdr0 :semibrevis 0 :dot)
;;   (:note sbdr1 :semibrevis 1 :dot)
;;   (:note sbdr2 :semibrevis 2 :dot)
;;   (:note sbdr3 :semibrevis 3 :dot)
;;   (:note sbdr4 :semibrevis 4 :dot)
;;   (:note sbdr5 :semibrevis 5 :dot)
;;   (:note sbdr6 :semibrevis 6 :dot)
;;   (:note sbdr7 :semibrevis 7 :dot)
;;   (:note sbdr8 :semibrevis 8 :dot)
;;   (:note sbdr9 :semibrevis 9 :dot)
;;   (:note sbdl0 :semibrevis 0 :dot)
;;   (:note sbdl1 :semibrevis 1 :dot)
;;   (:note sbdl2 :semibrevis 2 :dot)
;;   (:note sbdl3 :semibrevis 3 :dot)
;;   (:note sbdl4 :semibrevis 4 :dot)
;;   (:note sbdl5 :semibrevis 5 :dot)
;;   (:note sbdl6 :semibrevis 6 :dot)
;;   (:note sbdl7 :semibrevis 7 :dot)
;;   (:note sbdl8 :semibrevis 8 :dot)
;;   (:note sbdl9 :semibrevis 9 :dot)
;;   (:note sbc0 :semibrevis 0 :comma)
;;   (:note sbc1 :semibrevis 1 :comma)
;;   (:note sbc2 :semibrevis 2 :comma)
;;   (:note sbc3 :semibrevis 3 :comma)
;;   (:note sbc4 :semibrevis 4 :comma)
;;   (:note sbc5 :semibrevis 5 :comma)
;;   (:note sbc6 :semibrevis 6 :comma)
;;   (:note sbc7 :semibrevis 7 :comma)
;;   (:note sbc8 :semibrevis 8 :comma)
;;   (:note sbc9 :semibrevis 9 :comma)
;;   (:note sbc10 :semibrevis 10 :comma)
;;   (:note m-1 :minima -1)
;;   (:note m0 :minima 0)
;;   (:note m1 :minima 1)
;;   (:note m2 :minima 2)
;;   (:note m3 :minima 3)
;;   (:note m4 :minima 4)
;;   (:note m5 :minima 5)
;;   (:note m5d :minima 5)
;;   (:note m6 :minima 6)
;;   (:note m7 :minima 7)
;;   (:note m8 :minima 8)
;;   (:note m9 :minima 9)
;;   (:note m10 :minima 10)
;;   (:note md0 :minima 0 :dot)
;;   (:note md1 :minima 1 :dot)
;;   (:note md2 :minima 2 :dot)
;;   (:note md3 :minima 3 :dot)
;;   (:note md4 :minima 4 :dot)
;;   (:note md5 :minima 5 :dot)
;;   (:note md5d :minima 5 :dot)
;;   (:note md6 :minima 6 :dot)
;;   (:note md7 :minima 7 :dot)
;;   (:note md8 :minima 8 :dot)
;;   (:note md9 :minima 9 :dot)
;;   (:note md10 :minima 10 :dot)

;;   (:note mdr0 :minima 0 :dot)
;;   (:note mdr1 :minima 1 :dot)
;;   (:note mdr2 :minima 2 :dot)
;;   (:note mdr3 :minima 3 :dot)
;;   (:note mdr4 :minima 4 :dot)
;;   (:note mdr5 :minima 5 :dot)
;;   (:note mdr6 :minima 6 :dot)
;;   (:note mdr7 :minima 7 :dot)
;;   (:note mdr8 :minima 8 :dot)
;;   (:note mdr9 :minima 9 :dot)
;;   (:note mdr10 :minima 10 :dot)
;;   (:note mdl0 :minima 0 :dot)
;;   (:note mdl1 :minima 1 :dot)
;;   (:note mdl2 :minima 2 :dot)
;;   (:note mdl3 :minima 3 :dot)
;;   (:note mdl4 :minima 4 :dot)
;;   (:note mdl5 :minima 5 :dot)
;;   (:note mdl6 :minima 6 :dot)
;;   (:note mdl7 :minima 7 :dot)
;;   (:note mdl8 :minima 8 :dot)
;;   (:note mdl9 :minima 9 :dot)
;;   (:note mdl10 :minima 10 :dot)
;;   (:note sm0 :semiminima 0)
;;   (:note sm1 :semiminima 1)
;;   (:note sm2 :semiminima 2)
;;   (:note sm3 :semiminima 3)
;;   (:note sm4 :semiminima 4)
;;   (:note sm5 :semiminima 5)
;;   (:note sm5d :semiminima 5)
;;   (:note sm6 :semiminima 6)
;;   (:note sm7 :semiminima 7)
;;   (:note sm8 :semiminima 8)
;;   (:note sm9 :semiminima 9)
;;   (:note sm10 :semiminima 10)
;;   (:note smd0 :semiminima 0 :dot)
;;   (:note smd1 :semiminima 1 :dot)
;;   (:note smd2 :semiminima 2 :dot)
;;   (:note smd3 :semiminima 3 :dot)
;;   (:note smd4 :semiminima 4 :dot)
;;   (:note smd5 :semiminima 5 :dot)
;;   (:note smd5d :semiminima 5 :dot)
;;   (:note smd6 :semiminima 6 :dot)
;;   (:note smd7 :semiminima 7 :dot)
;;   (:note smd8 :semiminima 8 :dot)
;;   (:note smd9 :semiminima 9 :dot)
;;   (:note smd10 :semiminima 10 :dot)

;;   (:note smdr1 :semiminima 1 :dot)
;;   (:note smdr2 :semiminima 2 :dot)
;;   (:note smdr3 :semiminima 3 :dot)
;;   (:note smdr4 :semiminima 4 :dot)
;;   (:note smdr5 :semiminima 5 :dot)
;;   (:note smdr6 :semiminima 6 :dot)
;;   (:note smdr7 :semiminima 7 :dot)
;;   (:note smdr8 :semiminima 8 :dot)
;;   (:note smdr9 :semiminima 9 :dot)
;;   (:note smdl1 :semiminima 1 :dot)
;;   (:note smdl2 :semiminima 2 :dot)
;;   (:note smdl3 :semiminima 3 :dot)
;;   (:note smdl4 :semiminima 4 :dot)
;;   (:note smdl5 :semiminima 5 :dot)
;;   (:note smdl6 :semiminima 6 :dot)
;;   (:note smdl7 :semiminima 7 :dot)
;;   (:note smdl8 :semiminima 8 :dot)
;;   (:note smdl9 :semiminima 9 :dot)
;;   (:note cr0 :croma 0)
;;   (:note cr1 :croma 1)
;;   (:note cr2 :croma 2)
;;   (:note cr3 :croma 3)
;;   (:note cr4 :croma 4)
;;   (:note cr5 :croma 5)
;;   (:note cr5d :croma 5)
;;   (:note cr6 :croma 6)
;;   (:note cr7 :croma 7)
;;   (:note cr8 :croma 8)
;;   (:note cr9 :croma 9)
;;   (:note cr10 :croma 10)
;;   (:note crd7 :croma 7 :dot)
;;   (:note scr3 :semicroma 3)
;;   (:note scr4 :semicroma 4)
;;   (:note scr6 :semicroma 6)
;;   (:note scr7 :semicroma 7)
;;   (:note scrd2 :semicroma 2 :dot)
;;   (:rest maxrest246 :maxima)
;;   (:rest lrest24 :longa)
;;   (:rest lrest46 :longa)
;;   (:rest lrest68 :longa)
;;   (:rest brrest2 :brevis)
;;   (:rest brrest4 :brevis)
;;   (:rest brrest6 :brevis)
;;   (:rest sbrest3 :semibrevis)
;;   (:rest sbrest5 :semibrevis)
;;   (:rest sbrest7 :semibrevis)
;;   (:rest sbrest9 :semibrevis)
;;   (:rest mrest1 :minima)
;;   (:rest mrest3 :minima)
;;   (:rest mrest5 :minima)
;;   (:rest mrest7 :minima)
;;   (:rest smrest1 :semiminima)
;;   (:rest smrest3 :semiminima)
;;   (:rest smrest5 :semiminima)
;;   (:rest smrest7 :semiminima)
;;   ))

(defparameter *list-of-rests*
  '(
    lrest24 lrest46 lrest68
    brrest2 brrest4 brrest6 brrest8
    sbrest3 sbrest5 sbrest7 sbrest9
    mrest1 mrest3 mrest5 mrest7
    smrest1 smrest3 smrest5 smrest7
    ))

(defparameter *list-of-notes*
  '(
    longa1 longa2 longa3 longa4 longa5 longa6 longa7 longa8 longa9 longa10
    max0 max1 max2 max3 max4 max5 max6 max7 max8 max9 max10
    br0 br1 br2 br3 br4 br5 br6 br7 br8 br9 br10
    brd0 brd1 brd2 brd3 brd4 brd5 brd6 brd7 brd8 brd9 brd10
    sb0 sb1 sb2 sb3 sb4 sb5 sb6 sb7 sb8 sb9 sb10
    sbd0 sbd1 sbd2 sbd3 sbd4 sbd5 sbd6 sbd7 sbd8 sbd9 sbd10
    m0 m1 m2 m3 m4 m5 m6 m7 m8 m9 m10 m5d md5d
    md0 md1 md2 md3 md4 md5 md6 md7 md8 md9 md10
    sm0 sm1 sm2 sm3 sm4 sm5 sm6 sm7 sm8 sm9 sm10
    smd0 smd1 smd2 smd3 smd4 smd5 smd6 smd7 smd8 smd9 smd10
    cr0 cr1 cr2 cr3 cr4 cr5 cr6 cr7 cr8 cr9 cr10
    scr0 scr1 scr2 scr3 scr4 scr5 scr6 scr7 scr8 scr9 scr10
    )
  "This is used in the function to determine whether a note has a dotted duration value. Any glyph that can represent a dotted note should be member of this list.")

(defparameter *list-of-duration-dots*
  '(dot0 dot2 dot4 dot6 dot8 dot10)
  "This is used in the function looking ahead to detect rhythmic dots. All glyphs used to represent rhythmic dots should be member of this list.")

(defparameter *list-of-clefs*
  '(cclef1 cclef3 cclef5 cclef7
    fclef1 fclef3 fclef5 fclef7 fclef9
    gclef3))

(defparameter *f-clef-triggers*
  '(fclef1 fclef3 fclef5 fclef7 fclef9)
  "This is used to determine when the definition of an compound f-clef is done and normal glyph parsing can be switched back on. All glyphs that complete an f-clef complex should be member of this list.")

(defparameter *meter-signatures*
  '((met-perf-min-dim :circle nil :cut)
    (met-perf-min :circle nil nil)
    (met-perf-maj :circle :dot nil)
    (met-imperf-maj :semicircle :dot nil)
    (met-imperf-min-dim :semicircle nil :cut)
    (met-imperf-min :semicircle nil nil)))
